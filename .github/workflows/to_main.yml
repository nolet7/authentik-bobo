name: Complete CI/CD Deployment Pipeline

on:
  push:
    branches: [ main, develop, sre ]
    paths: 
      - 'helm/**'
      - 'docker-compose.yml'
      - 'nginx/**'
      - '.github/workflows/**'
  workflow_dispatch:

env:
  VAULT_ADDR: http://192.168.0.116:8200
  VAULT_PATH: secret/Dev-secret/authentik
  DOCKER_USER: noletengine
  REGISTRY: docker.io
  IMAGE_NAME_PREFIX: noletengine/authentik

jobs:
  # ==========================================
  # STAGE 1: BUILD AND TEST
  # ==========================================
  build-and-test:
    runs-on: self-hosted
    permissions:
      contents: read
      packages: write

    outputs:
      image-tag: ${{ steps.build.outputs.tag }}
      branch: ${{ steps.branch.outputs.branch }}
      environment: ${{ steps.branch.outputs.environment }}

    steps:
    - name: üõ† Checkout Repository
      uses: actions/checkout@v4

    - name: üî¢ Get Commit SHA and Branch Info
      id: branch
      run: |
        echo "COMMIT_SHA_SHORT=$(git rev-parse --short=4 HEAD)" >> $GITHUB_ENV
        BRANCH=${GITHUB_REF#refs/heads/}
        echo "branch=$BRANCH" >> $GITHUB_OUTPUT
        
        # Determine environment based on branch
        case "$BRANCH" in
          "main")
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "namespace=authentik-production" >> $GITHUB_OUTPUT
            echo "domain=auth.yourdomain.com" >> $GITHUB_OUTPUT
            ;;
          "develop")
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "namespace=authentik-staging" >> $GITHUB_OUTPUT
            echo "domain=auth-staging.yourdomain.com" >> $GITHUB_OUTPUT
            ;;
          "sre")
            echo "environment=sre" >> $GITHUB_OUTPUT
            echo "namespace=authentik-sre" >> $GITHUB_OUTPUT
            echo "domain=auth-sre.yourdomain.com" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: üîß Install Vault CLI
      run: |
        # Install vault CLI if not present
        if ! command -v vault &> /dev/null; then
          # Download and install Vault binary directly
          VAULT_VERSION="1.15.2"
          wget -O vault.zip "https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_linux_amd64.zip"
          unzip vault.zip
          sudo mv vault /usr/local/bin/
          sudo chmod +x /usr/local/bin/vault
          rm vault.zip
          
          # Verify installation
          vault version
        fi
    - name: üîê Authenticate with Vault and Extract Secrets
      run: |
        # Set Vault address and authenticate using token
        export VAULT_ADDR=${{ vars.VAULT_ADDR }}
        export VAULT_TOKEN=${{ secrets.VAULT_TOKEN }}
        
        # Verify authentication
        vault auth -method=token token=$VAULT_TOKEN
        
        # Extract secrets using the proven method from your working workflow
        vault kv get Dev-secret/authentik | grep -w AUTHENTIK_SECRET_KEY | awk '{print $1"="$2}' >> $GITHUB_ENV
        vault kv get Dev-secret/authentik | grep -w PG_PASS | awk '{print $1"="$2}' >> $GITHUB_ENV
        vault kv get Dev-secret/authentik | grep -w SMTP_HOST | awk '{print $1"="$2}' >> $GITHUB_ENV
        vault kv get Dev-secret/authentik | grep -w SMTP_PORT | awk '{print $1"="$2}' >> $GITHUB_ENV
        vault kv get Dev-secret/authentik | grep -w SMTP_USER | awk '{print $1"="$2}' >> $GITHUB_ENV
        vault kv get Dev-secret/authentik | grep -w SMTP_PASS | awk '{print $1"="$2}' >> $GITHUB_ENV
        vault kv get Dev-secret/authentik | grep -w DOMAIN_NAME | awk '{print $1"="$2}' >> $GITHUB_ENV
        
        # Set additional environment variables
        echo "POSTGRES_PASSWORD=$PG_PASS" >> $GITHUB_ENV
        echo "HOST_IP=192.168.0.2" >> $GITHUB_ENV

    - name: üê≥ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: üîë Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKER_USER }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: üèóÔ∏è Build and Test Images
      id: build
      run: |
        # Create .env file with Vault secrets
        cat > .env << EOF
        AUTHENTIK_SECRET_KEY=${{ env.AUTHENTIK_SECRET_KEY }}
        POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}
        POSTGRES_USER=authentik
        POSTGRES_DB=authentik
        SMTP_HOST=${{ env.SMTP_HOST }}
        SMTP_PORT=${{ env.SMTP_PORT }}
        SMTP_USER=${{ env.SMTP_USER }}
        SMTP_PASS=${{ env.SMTP_PASS }}
        SMTP_USE_TLS=true
        SMTP_USE_SSL=false
        SMTP_FROM=authentik@${{ env.DOMAIN_NAME }}
        DOMAIN_NAME=${{ env.DOMAIN_NAME }}
        HOST_IP=${{ env.HOST_IP }}
        AUTHENTIK_PORT_HTTP=9000
        AUTHENTIK_PORT_HTTPS=9443
        EOF
        
        # Generate image tag
        BRANCH=${{ steps.branch.outputs.branch }}
        TAG="${BRANCH}-${{ env.COMMIT_SHA_SHORT }}"
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        
        echo "üèóÔ∏è Building with tag: $TAG"
        
        # Clean up any existing containers
        docker-compose down || true
        docker system prune -f || true
        
        # Start containers to build images
        docker-compose up -d
        
        # Wait for containers to be ready and test
        echo "‚è≥ Waiting for containers to be ready..."
        sleep 60
        
        # Health check
        echo "üîç Running health checks..."
        docker-compose ps
        
        # Test database connection
        docker-compose exec -T postgresql pg_isready -U authentik -d authentik || {
          echo "‚ùå Database health check failed"
          docker-compose logs postgresql
          exit 1
        }
        
        # Test Redis connection
        docker-compose exec -T redis redis-cli ping || {
          echo "‚ùå Redis health check failed"
          docker-compose logs redis
          exit 1
        }
        
        # Test Authentik server
        timeout 30 bash -c 'until curl -f http://192.168.0.2:9000/-/health/live/ 2>/dev/null; do sleep 2; done' || {
          echo "‚ùå Authentik server health check failed"
          docker-compose logs server
          exit 1
        }
        
        echo "‚úÖ All health checks passed!"
        
        # Commit and tag images
        echo "üì¶ Committing and tagging images..."
        docker commit authentik_server ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-server:$TAG
        docker commit authentik_worker ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-worker:$TAG
        docker commit authentik_postgresql ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-postgresql:$TAG
        docker commit authentik_redis ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-redis:$TAG
        docker commit authentik_nginx ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-nginx:$TAG
        
        # Cleanup containers
        docker-compose down

    - name: üöÄ Push Images to Registry
      run: |
        TAG=${{ steps.build.outputs.tag }}
        
        echo "üöÄ Pushing images to registry..."
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-server:$TAG
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-worker:$TAG
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-postgresql:$TAG
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-redis:$TAG
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-nginx:$TAG
        
        # Tag as latest for main branch
        if [ "${{ steps.branch.outputs.branch }}" = "main" ]; then
          echo "üè∑Ô∏è Tagging as latest for main branch..."
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-server:$TAG ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-server:latest
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-worker:$TAG ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-worker:latest
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-postgresql:$TAG ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-postgresql:latest
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-redis:$TAG ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-redis:latest
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-nginx:$TAG ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-nginx:latest
          
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-server:latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-worker:latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-postgresql:latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-redis:latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-nginx:latest
        fi

    - name: üßπ Cleanup Build Environment
      if: always()
      run: |
        docker-compose down || true
        docker system prune -f || true

  # ==========================================
  # STAGE 2: UPDATE HELM VALUES
  # ==========================================
  update-helm-values:
    needs: build-and-test
    runs-on: self-hosted
    
    steps:
    - name: üõ† Checkout Repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: üìù Update Helm Values with New Image Tags
      run: |
        cd helm/authentik-chart
        TAG="${{ needs.build-and-test.outputs.image-tag }}"
        
        echo "üìù Updating Helm values with tag: $TAG"
        
        # Update all image tags in values.yaml
        sed -i "s/tag: \".*\"/tag: \"$TAG\"/" values.yaml
        
        # Verify changes
        echo "‚úÖ Updated values.yaml:"
        grep "tag:" values.yaml
        
        # Commit and push changes
        git config --local user.email "github-actions@github.com"
        git config --local user.name "GitHub Actions"
        git add values.yaml
        git commit -m "üöÄ Update image tags to $TAG [skip ci]" || exit 0
        git push

  # ==========================================
  # STAGE 3: DEPLOY TO KUBERNETES
  # ==========================================
  deploy-to-kubernetes:
    needs: [build-and-test, update-helm-values]
    runs-on: self-hosted
    
    steps:
    - name: üõ† Checkout Repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: üîÑ Pull Latest Changes
      run: |
        git pull origin ${{ needs.build-and-test.outputs.branch }}

    - name: üöÄ Deploy with ArgoCD
      run: |
        BRANCH="${{ needs.build-and-test.outputs.branch }}"
        ENVIRONMENT="${{ needs.build-and-test.outputs.environment }}"
        
        echo "üöÄ Deploying to $ENVIRONMENT environment..."
        
        case "$BRANCH" in
          "main")
            kubectl apply -f argocd/application-production.yaml
            APP_NAME="authentik-production"
            NAMESPACE="authentik-production"
            ;;
          "develop")
            kubectl apply -f argocd/application-staging.yaml
            APP_NAME="authentik-staging"
            NAMESPACE="authentik-staging"
            ;;
          "sre")
            kubectl apply -f argocd/application-sre.yaml
            APP_NAME="authentik-sre"
            NAMESPACE="authentik-sre"
            ;;
        esac
        
        echo "‚úÖ Applied ArgoCD application: $APP_NAME"

    - name: ‚è≥ Wait for ArgoCD Sync
      run: |
        BRANCH="${{ needs.build-and-test.outputs.branch }}"
        
        case "$BRANCH" in
          "main") APP_NAME="authentik-production" ;;
          "develop") APP_NAME="authentik-staging" ;;
          "sre") APP_NAME="authentik-sre" ;;
        esac
        
        echo "‚è≥ Waiting for ArgoCD to sync $APP_NAME..."
        
        # Wait for sync to complete
        for i in {1..30}; do
          SYNC_STATUS=$(kubectl get application $APP_NAME -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          HEALTH_STATUS=$(kubectl get application $APP_NAME -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
          
          echo "Attempt $i/30: Sync=$SYNC_STATUS, Health=$HEALTH_STATUS"
          
          if [[ "$SYNC_STATUS" == "Synced" && "$HEALTH_STATUS" == "Healthy" ]]; then
            echo "‚úÖ Application is synced and healthy!"
            break
          fi
          
          if [[ $i -eq 30 ]]; then
            echo "‚ö†Ô∏è Timeout waiting for sync, but continuing..."
          fi
          
          sleep 10
        done

    - name: üîç Verify Deployment
      run: |
        BRANCH="${{ needs.build-and-test.outputs.branch }}"
        
        case "$BRANCH" in
          "main")
            APP_NAME="authentik-production"
            NAMESPACE="authentik-production"
            ;;
          "develop")
            APP_NAME="authentik-staging"
            NAMESPACE="authentik-staging"
            ;;
          "sre")
            APP_NAME="authentik-sre"
            NAMESPACE="authentik-sre"
            ;;
        esac
        
        echo "üìä Checking ArgoCD application status..."
        kubectl get application $APP_NAME -n argocd || true
        
        echo "üìä Checking pods in $NAMESPACE..."
        kubectl get pods -n $NAMESPACE || true
        
        echo "üìä Checking services in $NAMESPACE..."
        kubectl get services -n $NAMESPACE || true
        
        echo "üìä Checking ingress in $NAMESPACE..."
        kubectl get ingress -n $NAMESPACE || true
        
        # Wait for pods to be ready
        echo "‚è≥ Waiting for pods to be ready..."
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=authentik-chart -n $NAMESPACE --timeout=300s || {
          echo "‚ö†Ô∏è Some pods may not be ready yet, checking status..."
          kubectl get pods -n $NAMESPACE
          kubectl describe pods -n $NAMESPACE
        }

  # ==========================================
  # STAGE 4: POST-DEPLOYMENT TESTS
  # ==========================================
  post-deployment-tests:
    needs: [build-and-test, deploy-to-kubernetes]
    runs-on: self-hosted
    if: always()
    
    steps:
    - name: üß™ Run Health Checks
      run: |
        BRANCH="${{ needs.build-and-test.outputs.branch }}"
        
        case "$BRANCH" in
          "main") NAMESPACE="authentik-production" ;;
          "develop") NAMESPACE="authentik-staging" ;;
          "sre") NAMESPACE="authentik-sre" ;;
        esac
        
        echo "üß™ Running post-deployment health checks..."
        
        # Check if pods are running
        RUNNING_PODS=$(kubectl get pods -n $NAMESPACE --field-selector=status.phase=Running --no-headers | wc -l)
        TOTAL_PODS=$(kubectl get pods -n $NAMESPACE --no-headers | wc -l)
        
        echo "üìä Pods Status: $RUNNING_PODS/$TOTAL_PODS running"
        
        if [[ $RUNNING_PODS -gt 0 ]]; then
          echo "‚úÖ At least some pods are running"
        else
          echo "‚ùå No pods are running"
          exit 1
        fi
        
        # Check services
        kubectl get services -n $NAMESPACE
        
        # Check ingress
        kubectl get ingress -n $NAMESPACE

    - name: üìß Send Notification (Optional)
      if: always()
      run: |
        BRANCH="${{ needs.build-and-test.outputs.branch }}"
        TAG="${{ needs.build-and-test.outputs.image-tag }}"
        STATUS="${{ job.status }}"
        
        echo "üìß Deployment Summary:"
        echo "Branch: $BRANCH"
        echo "Tag: $TAG"
        echo "Status: $STATUS"
        echo "Environment: ${{ needs.build-and-test.outputs.environment }}"

  # ==========================================
  # STAGE 5: DEPLOYMENT SUMMARY
  # ==========================================
  deployment-summary:
    needs: [build-and-test, update-helm-values, deploy-to-kubernetes, post-deployment-tests]
    runs-on: self-hosted
    if: always()
    
    steps:
    - name: üìã Generate Deployment Summary
      run: |
        BRANCH="${{ needs.build-and-test.outputs.branch }}"
        TAG="${{ needs.build-and-test.outputs.image-tag }}"
        ENVIRONMENT="${{ needs.build-and-test.outputs.environment }}"
        
        echo "üéâ Deployment Summary:"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "üì¶ Branch: $BRANCH"
        echo "üè∑Ô∏è Image Tag: $TAG"
        echo "üåç Environment: $ENVIRONMENT"
        echo "üê≥ Images Built: 5 (server, worker, postgresql, redis, nginx)"
        echo "‚ò∏Ô∏è Kubernetes Namespace: authentik-$ENVIRONMENT"
        echo "üåê Domain: auth$([ "$BRANCH" != "main" ] && echo "-$BRANCH").yourdomain.com"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        # Check final status
        BUILD_STATUS="${{ needs.build-and-test.result }}"
        HELM_STATUS="${{ needs.update-helm-values.result }}"
        DEPLOY_STATUS="${{ needs.deploy-to-kubernetes.result }}"
        TEST_STATUS="${{ needs.post-deployment-tests.result }}"
        
        echo "üìä Pipeline Status:"
        echo "üèóÔ∏è Build & Test: $BUILD_STATUS"
        echo "üìù Helm Update: $HELM_STATUS"
        echo "üöÄ Deployment: $DEPLOY_STATUS"
        echo "üß™ Post-Deploy Tests: $TEST_STATUS"
        
        if [[ "$BUILD_STATUS" == "success" && "$HELM_STATUS" == "success" && "$DEPLOY_STATUS" == "success" ]]; then
          echo "‚úÖ Deployment completed successfully!"
          exit 0
        else
          echo "‚ùå Deployment had issues. Check individual job logs."
          exit 1
        fi
